C# Job System

overview

Unity C#Job 允许使用者编写简单易用的多线程代码，并且提供了和Unity本身良好的交互

编写多线程代码可以提供很好的性能表现，比如非常重要的帧率表现，使用Job的BurstCompile可以生成更高质量的代码，并且可以在移动设备上减少电量的持续消耗。

一个很重要的地方是，job整合了Unity的内部资源（Unity本地的工作系统），业务代码和Unity共享工作线程。这个合作避免创建大于内核数量的线程，避免了cpu资源的争夺。

什么是Job System？

Job System通过创建一个Job而不是线程来管理多线程代码，Job System在多个内核之间管理工作线程，通常一个cpu内核有一个初始线程，来避免线程上下文的切换。

Job System将多个Job放入一个工作队列去执行，工作线程从这里获取并执行他们，这个系统同样需要保证管理他们的依赖，并确保按照合适的顺序执行。

what is a job？

Job是一个很小的工作单元，接收参数并操作数据，类似一个函数方法的执行行为，job可能是独立的，也可能依赖于其他job的执行结果。

什么是job之间的依赖？

在复杂的系统里，比如游戏开发的需求，通常job并不会是独立的，一个job通常是为另一个job准备数据，Job系统支持了这个特性，如果任务a依赖于任务b，系统会保证他们有正确的执行顺序。

C# Job System里的安全系统

当你编写多线程代码的时候，通常会有数据竞争的风险，当一个操作的输出依赖于其控制范围之外的另一个进程的执行时间时，就会出现数据竞争条件。
数据竞争通常不算是bug，但是是一种不确定的行为，当一个数据竞争引发一个bug，由于时间的不确定性将会很难发现bug的真正原因，因为只能靠数据竞争才能重现bug。在代码中debug可能导致问题莫名消失，因为断点调试和log会改变线程的时间节点，数据竞争大大增加了多线程开发的挑战。

安全系统

为了让多线程开发变得简单，C# job system检测所有潜在的数据竞争，并且规避可能导致的bug。
比如：当在你的主线程代码中向job发送了一个数据的引用，此时无法查证当主线程在读取数据的同时，job是否在尝试写入，此时便产生数据竞争。

C# JobSystem通过发送每个job一份操作数据的拷贝，而不是主线程数据的引用，来解决数据竞争问题。这份拷贝隔离了数据，因此得以解决数据竞争问题。

Job System需要拷贝数据，意味着job只能访问blittable的数据类型，这些数据类型在本地和托管代码中不需要转换。

job system可以使用memcpy来拷贝blittable的数据，并且在unity的本地堆和托管堆之间转换，他在调度job的时候，使用memcpy来将数据放入本地内存，并赋予数据的管理权限。














